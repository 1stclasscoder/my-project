# Simple Docker

## Part 1. Готовый докер


##### Загрузка официального докер-образ с **nginx** и выгрузка его при помощи `docker pull`. <br>
![Загрузка docker_file](images/1.1.png) <br>

##### Проверка наличия докер-образа через `docker images`.
![Проверка docker_file](images/1.2.png)

##### Запусти докер-образ через `docker run -d [image_id|repository]`. <br>
![Запуск докер-образа](images/1.3.png) <br>

Флаг -d — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.

##### Проверка, что образ запустился через `docker ps`. <br>
![Проверка запуска](images/1.4.png) <br>

##### Просмотр информации о контейнере через `docker inspect [container_id|container_name]`. <br>
![Информация о контейнере](images/1.5.png) <br>

##### Размер контейнера: <br>
![Размер контейнера](images/1.6.png) <br>

##### Список замапленных портов: <br>
![Список замапленных портов](images/1.7.png) <br>

##### ip контейнера: <br>
![ip контейнера](images/1.8.png) <br>

##### Остановка докер образа через  `docker stop [container_id|container_name]`. <br>
![Остановка докер образа](images/1.9.png) <br>

##### Проверка, что образ остановился через `docker ps`. <br>
![Проверка, что образ остановился](images/1.10.png) <br>

##### Запуск докера с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду *run*. <br>
![Запуск докера с портами 80 и 443](images/1.11.png) <br>

- docker run: команда для запуска контейнера.
- -p 80:80: опция для прокидывания порта контейнера на хост-систему. В этом случае порт 80 контейнера будет доступен по порту 80 хост-системы.
- -p 443:443: аналогично предыдущей опции, но для порта 443, который обычно используется для HTTPS соединений.
- nginx: имя образа, который будет использован для запуска контейнера.

С помощью этой команды мы запускаем контейнер с веб-сервером Nginx в фоновом режиме и прокидываем порты 80 и 443 с контейнера на хост-систему, чтобы можно было обращаться к веб-серверу через HTTP и HTTPS соответственно.

##### Проверка, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**. <br>
![Проверка localhost](images/1.12.png) <br>

##### Перезапуск докер контейнера через `docker restart [container_id|container_name]`. <br>
![Перезапуск докер контейнера](images/1.13.png) <br>

##### Проверка, что контейнер запустился. <br>
![Проверка запуска](images/1.14.png) <br>

## Part 2. Операции с контейнером

##### Прочтение конфигурационного файла *nginx.conf* внутри докер контейнера через команду *exec*. <br>
![Прочтение nginx.conf](images/2.1.png) <br>
- docker exec: команда для выполнения команд в контейнере

##### Создание на локальной машине файл *nginx.conf*. <br>
![Создание nginx.conf](images/2.2.png) <br>

##### Настройка в нем по пути */status* отдачу страницы статуса сервера **nginx**.
Модуль ngx_http_status_module предоставляет доступ к информации о состоянии сервера.
Для активации закоментил    # include /etc/nginx/conf.d/*.conf; <br>
![Настройка nginx.conf](images/2.3.png) <br>

##### Скопируем созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp` (docker cp nginx.conf objective_heyrovsky:etc/nginx/) и перезапустим **nginx** внутри докер-образа через команду *exec* (docker exec objective_heyrovsky nginx -s reload). <br>
![Активация nginx.conf](images/2.4.png) <br>
Флаг -s reload используется для отправки сигнала перезагрузки Nginx серверу, который запущен внутри контейнера. 

##### Проверка, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**. <br>
![Проверка nginx.conf](images/2.5.png) <br>

##### Экспортируем контейнер в файл *container.tar* через команду *export*. <br>
![Экспорт container.tar](images/2.6.png) <br>

##### Остановка контейнера. <br>
![Остановка контейнера](images/2.7.png) <br>

##### Удаление образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры и после этого удаление остановленного контейнера. <br>
![Удаление контейнера](images/2.8.png) <br>

##### Импорт контейнера обратно через команду *import*. <br>
![Удаление контейнера](images/2.9.png) <br>
Команда docker import используется для создания нового образа Docker, импортируя контейнер в виде файла tar или архив. Здесь container.tar является файлом, который содержит файловую систему контейнера.

Флаг -c 'CMD ["nginx", "-g", "daemon off;"]' задает команду (CMD) по умолчанию для контейнера. В данном случае, создаваемый образ будет содержать команду запуска Nginx с параметром -g "daemon off;". Это означает, что при запуске контейнера на основе этого образа, Nginx будет запускаться с указанным параметром.

Таким образом, данная команда создаст новый образ Docker из файла container.tar с указанной командой по умолчанию для запуска Nginx.

##### Запуск импортированного контейнера. <br>
![Запуск импортированного контейнера](images/2.10.png) <br>

##### Проверка, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**. <br>
![Проверка localhost:80/status](images/2.11.png) <br>

## Part 3. Мини веб-сервер

##### Мини-сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello World!`.
https://lectureswww.readthedocs.io/5.web.server/fcgi.html // лекция по написанию минисервера <br>
![Написание  мини-сервера на **C** и **FastCgi**](images/3.1.png) <br>
##### Напиcание своего *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*. <br>
![Изменение nginx.conf файла](images/3.2.png) <br>

##### Запуск мини-сервера через *spawn-fcgi* на порту 8080.

##### Копирование файлов в докер: <br>
![copy](images/3.3.png) <br>

##### Вход в контейнер, обновление пакетов и устанавливаем gcc, spawn-fcgi и libfcgi-dev: <br>
![intarnce](images/3.4.png) <br>
![set](images/3.5.png)

##### Запуск: <br>
![Use](images/3.6.png) <br>

##### Проверка, что в браузере по *localhost:81* отдается написанная тобой страничка. <br>
![check](images/3.7.png) <br>

##### Копирование файла *nginx.conf* по пути *./nginx/nginx.conf*. <br>
![copy](images/3.8.png) <br>

## Part 4. Свой докер

#### Докер-образ, который:
##### 1) собирает исходники мини сервера на FastCgi из [Части 3](#part-3-мини-веб-сервер);
##### 2) запускает его на 8080 порту;
##### 3) копирует внутрь образа написанный *./nginx/nginx.conf*;
##### 4) запускает **nginx**.

#####Написание Dockerfile: <br>
![copy](images/4.1.png) <br>

#####Написание скриптов: <br>
![copy](images/4.2.png) <br>

##### Сборка написанный докер-образ через `docker build` при этом указав имя и тег. <br>
![copy](images/4.3.png) <br>
Флаг -t в команде "Docked Build" указывает на то, что необходимо сначала заново создать образ контейнера перед его запуском.

##### Проверка через `docker images`, что все собралось корректно. <br>
![check](images/4.4.png) <br>

##### Запуск докер-образа с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а. <br>
![use](images/4.5.png) <br>
оманда docker run используется для запуска контейнера Docker на основе указанного образа. В данном случае, контейнер будет запущен на основе образа yrelcary:1.0 и будет выполнять команду bash в интерактивном режиме.

Флаги и их действия в данной команде:

1. -it: Комбинация двух флагов -i (интерактивный) и -t (терминал) позволяет запустить контейнер в интерактивном режиме с открытым терминалом.
   
2. -p 80:81: Перенаправляет порт 80 из хоста на порт 81 внутри контейнера. Таким образом, все запросы на порт 80 хоста будут перенаправлены на порт 81 контейнера.
   
3. -v /Users/germanmuraev/Desktop/D05_SimpleDocker-1/src/part4/nginx.conf:/etc/nginx/nginx.conf: Создает привязку тома между локальным файлом nginx.conf на рабочем столе и файлом внутри контейнера /etc/nginx/nginx.conf. Это позволяет подключить локальный файл к контейнеру для использования его внутри контейнера.

##### Проверка, что по localhost:80 доступна страничка написанного мини сервера. <br>
![check](images/4.6.png) <br>

##### Проксирование странички */status*, по которой надо отдавать статус сервера **nginx**. <br>
![Проксирование](images/4.7.png) <br>

##### Перезапуск докер-образ. <br>
![Проксирование](images/4.8.png) <br>

##### Проверка, что теперь по *localhost:80/status* отдается страничка со статусом **nginx** <br>
![Проверка1](images/4.9.png) <br>
![Проверка2](images/4.10.png) <br>

*Всё сделано верно, поэтому после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий*

## Part 5. **Dockle**
##### Установка DOckle. <br>
![Set](images/5.1.png) <br>

##### Сканирование образа из предыдущего задания через `dockle [image_id|repository]`. <br>
![Скан](images/5.2.png) <br>

##### Исправление образа так, чтобы при проверке через **dockle** не было ошибок и предупреждений. <br>
![Скан](images/5.3.png) <br>
1) chown -R nginx:nginx /etc/nginx/nginx.conf: изменяет владельца и группу файла nginx.conf на nginx:nginx.
2) chown -R nginx:nginx /var/cache/nginx: изменяет владельца и группу директории /var/cache/nginx на nginx:nginx.
3) chown -R nginx:nginx /home: изменяет владельца и группу директории /home на nginx:nginx.
4) touch /var/run/nginx.pid: создает файл nginx.pid в директории /var/run/.
5) chown -R nginx:nginx /var/run/nginx.pid: изменяет владельца и группу файла nginx.pid на nginx:nginx.
6) rm -rf /var/lib/apt/lists: удаляет директорию /var/lib/apt/lists для очистки кэша пакетов.
7) USER nginx: задает пользователя nginx для выполнения последующих инструкций.
9) Команда HEALTHCHECK NONE в Docker используется для отключения проверки здоровья контейнера. По умолчанию Docker запускает проверку здоровья на основе директивы HEALTHCHECK в Dockerfile, но если эта проверка не требуется, можно использовать указанную команду для отключения ее выполнения.

##### Создаем новый образ.
![Скан](images/5.4.png) <br>

##### Используем флаг -i CIS-DI-0010, чтобы не показывало первую ошибку, связанную с нарушениями харнения данных. <br>
![Скан](images/5.5.png)
Когда мы используем команду dockle -i CIS-DI-0010, мы указываем утилите Dockle (клеточный сканер для контейнеров) выполнить проверку с определенным идентификатором уязвимости CIS-DI-0010.

Идентификаторы CIS-DI (CIS Docker Image) обычно указывают на конкретные уязвимости или нарушения безопасности в образах Docker, как это определено стандартами безопасности CIS (Center for Internet Security).


## Part 6. Базовый **Docker Compose**

##### Написание файла *docker-compose.yml*, с помощью которого:
##### 1) Поднятие докер-контейнера.
##### 2) Поднятие докер-контейнера с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.
##### Мапинг 8080 порта второго контейнера на 80 порт локальной машины. <br>
![yml](images/6.1.png) <br>
![nginx](images/6.2.png) <br>

##### Сборка и запуск проекта с помощью команд `docker-compose build` и `docker-compose up`. <br>
![File](images/6.3.png) <br>
##### Проверка, что в браузере по *localhost:80* отдается написанная тобой страничка, как и ранее. <br>
![localhost](images/6.4.png) <br>